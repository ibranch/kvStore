#!/usr/bin/env python

import sys, socket, select, time, json, random

ELECTION_TIMEOUT = float(random.randrange(150, 300)) / 1000 # Convert to ms
HEARTBEAT_TIMEOUT = .140

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

lastClock, currentTerm, commitIndex, lastApplied = 0
candidate = False
leader_id = None
votedFor = (-1, None) # (term, id)
votesForMe = []
log = []
stateMachine = {}

def sendToAll(message):
    global replica_ids
    for server in replica_ids:
        message['dst'] = server
        sock.send(message)


def sendAppendEntries(prevLogIndex, prevLogTermEntries, entries=None):
    global my_id, lastClock, commitIndex
    lastClock = time.time()
    message = json.dumps({'src': my_id,
                          'term': currentTerm,
                          'type': 'append',
                          'prevLogIndex:': prevLogIndex,
                          'entries': entries,
                          'prevLogTermEntries': prevLogTermEntries,
                          'leaderCommit': commitIndex})

    sendToAll(message)


def AppendEntries(term, leaderId, prevLogIndex, prevLogTermEntries, leaderCommit, entries):
    global lastClock, votesForMe, candidate, leader_id, currentTerm, log, commitIndex

    msg = {'src': my_id, 'type': 'ack', 'dst': leader_id}
    # Listen to your
    lastClock = time.time() # This is ONLY updated on vote requests and heartbeats
    leader_id = leaderId
    # When it's calling for yooooou
    if prevLogTermEntries >= currentTerm and candidate:
        # transition out of the candidate state, if we were in it
        votesForMe = []
        candidate = False

    #the leader is behind the follower
    if term < currentTerm:
        msg['value'] = False
    else:
        # terms are the same
        try:
            if log[prevLogIndex][0] != prevLogTermEntries:
                log = log[:prevLogIndex]
            log.append(entries)
            msg['value'] = True

            if leaderCommit > commitIndex:
                commitIndex = min(leaderCommit, len(log) - 1)

        except ValueError:
            # the leader is ahead of the follower
            msg['value'] = False

    if term > currentTerm:
        currentTerm = term

    try:
        msg['term'] = currentTerm if msg['value'] else log[len(log)-1][0]
    except ValueError:
        msg['term'] = 0

    sock.send(json.dumps(msg))




def RequestVote():
    global lastClock, candidate, votedFor, votesForMe, leader_id
    lastClock = time.time() # This is ONLY updated on vote requests and heartbeats
    candidate = True
    votedFor = my_id
    votesForMe = [my_id]
    message = json.dumps({'src': my_id,
                          'leader': leader_id,
                          'type': 'election',
                          'term': currentTerm,
                          'logLength': len(log),
                          'lastLogTerm': log[len(log) - 1][0]})

    sendToAll(message)


def VoteRequested(term, candidateId, logLength, lastLogTerm):
    global votedFor, leader_id, currentTerm
    message = json.dumps({'src': my_id,
                          'dst': candidateId,
                          'leader': leader_id,
                          'type': 'vote'})
    if term < currentTerm or votedFor[0] > term:
        message['vote'] = False
    else:
        if votedFor[0] is not term or votedFor[1] == candidateId:
            message['vote'] = True
            votedFor = (term, candidateId)
        else:
            message['vote'] = False

    if currentTerm < term:
        currentTerm = term

    sock.send(message)


def get(msg):
    global my_id, leader_id, stateMachine
    src = msg['src']
    MID = msg['MID']
    key = msg['key']
    message = json.dumps({'src': my_id,
                          'dst': src,
                          'leader': leader_id,
                          'MID': MID})

    if leader_id != my_id:
        message['type'] = 'redirect'
    else:
        # I am the leader!
        try:
            value = stateMachine[key]
            message['value'] = value
        except KeyError:
            message['value'] = ''

    sock.send(message)


def put(msg):
    global my_id, leader_id, log, stateMachine
    # src = msg['src']
    # MID = msg['MID']
    # key = msg['key']
    # message = json.dumps({'src': my_id,
    #                       'dst': src,
    #                       'leader': leader_id,
    #                       'MID': MID})

    if leader_id != my_id:
        message['type'] = 'redirect'
    else:
        # I am the leader!
        prevLogIndex = len(log) - 1
        prevLogIndexTerm = 0

        if prevLogIndex != -1:
            prevLogIndexTerm = log[prevLogIndex][0]

        log.append((currentTerm, msg))
        sendAppendEntries(prevLogIndex, prevLogIndexTerm)


while True:
    ready = select.select([sock], [], [], 0.1)[0]

    if sock in ready:
        msg_raw = sock.recv(32768)

        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)

        # Candidate
        if candidate:
            if msg['type'] == 'vote' and msg['vote']:
                #  Vote for Pedro!
                votesForMe.append(msg['src'])
            if len(votesForMe) >= (len(replica_ids) / 2):
                # Look at me. I am the leader now.
                sendAppendEntries()
                candidate = False
                votesForMe = []
                leader_id = my_id

        # Follower
        if msg['type'] == 'get':
            get(msg)
        elif msg['type'] == 'put':
            put(msg)
        elif msg['type'] == 'election':
            VoteRequested(msg['term'], msg['src'], msg['logLength'], msg['lastLogTerm'])
        elif msg['type'] == 'append':
            AppendEntries(msg['term'], msg['src'], msg['prevLogIndex'], msg['prevLogTermEntries'], msg['leaderCommit'], msg['entries'])
        elif msg['type'] == 'ack':
            CommitEntry()

    # Leader
    if leader_id == my_id:
        if lastClock - time.time() > HEARTBEAT_TIMEOUT:
            sendAppendEntries(None, None)
        else:
            # This is calls to append entries
            # TODO implement all that stuff
            sendAppendEntries(NotImplemented, NotImplemented, NotImplemented)

    clock = time.time()
    if clock - lastClock > ELECTION_TIMEOUT:
        # Initiate an election
        currentTerm += 1
        RequestVote()
